[
  {
    "objectID": "polarization_visuals.html",
    "href": "polarization_visuals.html",
    "title": "The Shape of a Magnetic Field",
    "section": "",
    "text": "This notebook is written as a testset for the sinar package and its polarization capabilities with sinar.entities.harmonics.\n\n\nCode\nimport jax\nimport jax.numpy as jnp\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\n\nfrom sinar.entities.shapes import rotation\n\n\n\nMagnetic Field Vector\nWithout any magnetic monopoles, magnetic fields must satisfy \\(\\nabla \\cdot \\vec{B} = 0\\). For any potential \\(V\\) that is able to describe a magnetic field, i.e. \\(\\vec{B} = \\nabla V\\), the constraint on no-magnetic-monopoles translates to Laplace’s equation: \\(\\nabla^2 V = 0\\) or \\(\\Delta V = 0\\), whose solutions in 3-dimensions are the spherical harmonics.\nTo compute the magnetic field vectors, the dipole_vector function is used from sinar.entities.harmonics.\n\n\nCode\nfrom sinar.entities.harmonics import dipole_vector\n\ndef view_field(ax, elev_view=25, azim_view=30, orient=jnp.eye(3),\n               field_components=jnp.array([1.0, 0.0]),\n               title = \"\"):\n    ax.view_init(elev=elev_view, azim=azim_view)\n    \n    # Grid points on the unit sphere\n    elev = jnp.linspace(0, jnp.pi, 30)\n    azim = jnp.linspace(0, 2*jnp.pi, 30)\n    elev_grid, azim_grid = jnp.meshgrid(elev, azim)\n    \n    # Cartesian coordinates of the grid points\n    x = jnp.sin(elev_grid) * jnp.cos(azim_grid)\n    y = jnp.sin(elev_grid) * jnp.sin(azim_grid)\n    z = jnp.cos(elev_grid)\n    positions = jnp.stack([x, y, z], axis=-1)\n    \n    # Calculate magnetic vector field\n    field = jax.vmap(lambda pos: dipole_vector(field_components, orient, pos))\n    b = field(positions.reshape(-1, 3)).reshape((*elev_grid.shape, 3))\n    \n    # Extract components and calculate magnitude\n    magnitude = jnp.linalg.norm(b, axis=-1)\n    \n    # Plot the sphere and prepare colors\n    ax.plot_surface(x, y, z, color='lightblue', alpha=0.1)\n    norm = plt.Normalize(magnitude.min(), magnitude.max())\n    colors = cm.viridis(norm(magnitude)).reshape(-1, 4)\n    \n    # Plot the vector field (flattening in one step)\n    ax.quiver(x.flatten(), y.flatten(), z.flatten(),\n              b[:, :, 0].flatten(), b[:, :, 1].flatten(), b[:, :, 2].flatten(),\n              length=0.25, normalize=True, color=colors)\n    \n    # Set labels and limits\n    ax.set(xlabel='X', ylabel='Y', zlabel='Z', \n           xlim=[-1.2, 1.2], ylim=[-1.2, 1.2], zlim=[-1.2, 1.2],\n           title=title)\n\n\n\n\nCode\ndipole_component = jnp.array([1.0, 0.0, 0.0])\nquadrupole_component = jnp.array([0.0, 1.0, 0.0])\noctupole_component = jnp.array([0.0, 0.0, 1.0])\n\n\nFor ease of comparison of the magnetic field vector topology, the plots are shown in a single figure, side-by-side.\n\n\nCode\nfig = plt.figure(figsize=(12, 8))\nax1 = fig.add_subplot(231, projection='3d')\nelev_view, azim_view = 10, 21\nview_field(ax1, elev_view=elev_view, azim_view=azim_view,\n           field_components=dipole_component,\n           title = \"Pure Dipole\")\nax2 = fig.add_subplot(232, projection='3d')\nview_field(ax2, elev_view=elev_view, azim_view=azim_view,\n           field_components=quadrupole_component,\n           title = \"Pure Quadrupole\")\nax3 = fig.add_subplot(233, projection='3d')\nview_field(ax3, elev_view=elev_view, azim_view=azim_view,\n           field_components=octupole_component,\n           title = \"Pure Octupole Field\")\nax5 = fig.add_subplot(235, projection='3d')\nview_field(ax5, elev_view=elev_view, azim_view=azim_view,\n           field_components=dipole_component+quadrupole_component,\n           title = \"Dipole + Quadrupole\")\nax6 = fig.add_subplot(236, projection='3d')\nview_field(ax6, elev_view=elev_view, azim_view=azim_view,\n           field_components=dipole_component+octupole_component,\n           title = \"Dipole + Octupole\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\nFrom viewing the magnetic field vectors, it is clear that there are differences with the directions. When summed together, the magnetic field directions no longer look as neat as the pure dipole picture.\nWhile at the nothern hemisphere, the magnetic field vectors can appear as similar to a dipole, maybe with a different component strength, the vector directions diverge more significantly in the southern hemisphere. This has implications for the phase-resolved and the overall geometric effect of the polarization.\n\n\nPolarization Vectors\nThe Stokes parameters \\((I, Q, U, V)\\) describe the polarization of the light rays.\n\\(I\\): total intensity; \\(Q\\): linear polarization in + pattern; \\(U\\): linear polarization in x pattern; \\(V\\): circular polarization, with positive values being right-handed.\nWhile the Stokes parameters in any shared reference frame (like the detector-frame) are additive, the Stokes parameters of any particular ray are initially known only in relation to quantities in its local reference frame. This local reference frame consists of the propagation direction \\(\\vec{k}\\), and the two directions orthogonal to it: \\(\\vec{e}_1\\) and \\(\\vec{e}_2\\). For describing the polarization states relevant for highly magnetised neutron stars, the two polarization mode directions (X-mode and O-mode) are defined by their relation with the magnetic field direction \\(\\vec{B}\\), which is not local to the detector. In this case, \\(\\vec{e}_1 = \\vec{k} \\times \\vec{B}\\) and hence \\(\\vec{e}_2 = \\vec{e}_1 \\times \\vec{k}\\).\nTo obtain the Stokes parameters at the detector from the ray requires a transformation between the local ray frame and the detector frame: \\(\\vec{x}, \\vec{y}, \\vec{z}\\).\nIn the treatment here, the ray direction \\(\\vec{k}\\) and \\(\\vec{z}\\) are parallel. Thus, for each ray, there is only a rotation about the \\(\\vec{k}\\) axis to consider.\n\\(\\vec{e}_1 \\cdot \\vec{x} = \\cos(\\alpha)\\), where \\(\\alpha\\) is the angle of rotation required. The rotation between the frames is fully specified through \\(\\vec{e}_1\\) only because \\(\\vec{e}_1 \\cdot \\vec{y} = \\sin(\\alpha)\\) (using orthogonality of the bases).\nThe transformation from the local ray Stokes parameters to the detector Stokes parameters is given by: \\[\n\\mathcal{I} = I, \\\\\n\\mathcal{Q} = Q \\cos(2\\alpha) + U \\sin(2\\alpha), \\\\\n\\mathcal{U} = -Q \\sin(2\\alpha) + U \\cos(2\\alpha), \\\\\n\\mathcal{V} = V,\n\\] where the curly symbols denote the detector-frame Stokes parameters.\nFrom sinar.entities.harmonics, the utility function cross_and_project provides the value \\(\\vec{e}_1 \\cdot \\vec{x}\\) and \\(\\vec{e}_2 \\cdot \\vec{x}\\).\nCurrently, the calculation in view_projection is done for 100% purely linearly polarized light with Stokes parameters \\(I = 0, \\ Q=1, \\ U=0, \\ V=0\\), which is equivalent to 100% locally purely X-mode polarized light. This showcases the largest effects of the varying magnetic field topology on the polarization state.\n\n\nCode\nfrom sinar.entities.harmonics import cross_and_project\n\ndef view_projection(ax, \n                    field_components=jnp.array([1.0, 0.0]),\n                    orient = rotation(theta=jnp.pi/2),\n                    adiabatic_radius = 1.0,\n                    title=\"\"):\n    # Create a grid for the x-y plane\n    x = jnp.linspace(-1, 1, 40)\n    y = jnp.linspace(-1, 1, 40)\n    X, Y = jnp.meshgrid(x, y)\n\n    radii_xy = jnp.sqrt(X**2 + Y**2)\n    # For a particular adiabatic radius, the Z component makes up the remainder\n    # whereas the NS emission surface remains as bounded by 1.0\n    Z = jnp.where(radii_xy &lt;= 1.0, jnp.sqrt(adiabatic_radius - radii_xy**2), 0.0)\n    positions = jnp.stack([X, Y, Z], axis=-1)\n\n    ray_dir = jnp.array([0.0, 0.0, 1.0])\n    # The field computes cos(alpha), sin(alpha) between the local frame e1, e2 directions\n    # and the x, y directions in the detector frame\n    field = jax.vmap(lambda pos: cross_and_project(field_components,\n                                                   orient, \n                                                   pos, \n                                                   ray_dir))\n    cos, sin = field(positions.reshape(-1, 3))\n    cos = cos.reshape(X.shape)\n    sin = sin.reshape(Y.shape)\n    # Rotation from the local Stokes Q-U frame to the detector frame,\n    # assuming 100% linear polarization Q everywhere.\n    # This part has to be modified if there is a mix of polarization modes everywhere.\n    Q = cos**2 - sin**2\n    U = -sin*cos*2.0\n    \n    # Calculate absolute values for color mapping\n    Q_abs = Q\n    U_abs = U\n    \n    # TODO: Figure out a way to properly represent in terms of colors:\n    Q_norm = jnp.clip(0.5 * Q_abs / jnp.max(Q_abs) + 0.5, min=0.0, max=1.0)\n    U_norm = jnp.clip(0.5 * U_abs / jnp.max(U_abs) + 0.5, min=0.0, max=1.0)\n    \n    colors = jnp.stack([Q_norm, 0.5 * jnp.ones_like(U), U_norm, (radii_xy &lt;= 1.0).astype(jnp.float32)], axis=-1)\n    \n    # Plot the color map\n    ax.imshow(colors, origin='lower', extent=[-1, 1, -1, 1], aspect='equal')\n    \n    # Set plot labels and properties\n    ax.set_title(title)\n    ax.set_xlabel('x')\n    ax.set_ylabel('y')\n    ax.axis('equal')\n\n\n\n\nCode\ndef create_frame(fig, orient = rotation(theta=jnp.pi/4, phi=0.0), adiabatic_radius = 1.0):\n    ax1 = fig.add_subplot(231)\n    view_projection(ax1, field_components=dipole_component,\n                    orient = orient,\n                    adiabatic_radius = adiabatic_radius,\n                    title=\"Pure Dipole\")\n    ax2 = fig.add_subplot(232)\n    view_projection(ax2, field_components=quadrupole_component,\n                    orient = orient,\n                    adiabatic_radius = adiabatic_radius,\n                    title=\"Pure Quadrupole\")\n    ax3 = fig.add_subplot(233)\n    view_projection(ax3, field_components=octupole_component, \n                    orient = orient,\n                    adiabatic_radius = adiabatic_radius,\n                    title=\"Pure Octupole\")\n    ax5 = fig.add_subplot(235)\n    view_projection(ax5, field_components=dipole_component+quadrupole_component, \n                    orient = orient,\n                    adiabatic_radius = adiabatic_radius,\n                    title=\"Dipole + Quadrupole\")\n    ax6 = fig.add_subplot(236)\n    view_projection(ax6, field_components=dipole_component+octupole_component, \n                    orient = orient,\n                    adiabatic_radius = adiabatic_radius,\n                    title=\"Dipole + Octupole\")\n\nfig = plt.figure(figsize=(12, 8))\ncreate_frame(fig, adiabatic_radius=1.0)\nplt.show()\n\n\n\n\n\n\n\n\n\nThe differences of the multi-polar magnetic fields are more pronounced closer to the equator and in the southern hemisphere when compared with the pure dipole magnetic field.\nThe adiabatic radius, where the measurement of the polarization state of the light ray is taken, is an important factor in the how much the multi-polar components affect the polarization state. For an adiabatic radius farther from the surface, the higher-order components fall-off in strength compared with the dipole, which thus dominates the determination of the direction. Hence, the magnetic field topologies of interest are those in which the higher-order components at least dominate close to the surface (by a factor of several).\nThe best probes for complex magnetic field topology are lower energy photons, which will have a smaller adiabatic radius in comparison to higher energy photons.\n\n\nCode\nfrom matplotlib.animation import FuncAnimation\nimport numpy as np\n# Number of frames for the full 360-degree rotation\nn_frames = 36  # 10-degree steps\nphi_values = np.linspace(0, 2*jnp.pi, n_frames)\n\ndef create_animation(quad_scale = 1.0, octu_scale = 1.0,\n                     theta = jnp.pi/2.1, \n                     adiabatic_radius = 1.0):\n    fig = plt.figure(figsize=(12, 8))\n    \n    # Initialize the subplots\n    ax1 = fig.add_subplot(231)\n    ax2 = fig.add_subplot(232)\n    ax3 = fig.add_subplot(233)\n    ax5 = fig.add_subplot(235)\n    ax6 = fig.add_subplot(236)\n    \n    # Function to update the plot for each frame\n    def update(frame):\n        phi = phi_values[frame]\n        orient = rotation(theta=theta, phi=phi)\n        \n        # Clear axes\n        for ax in [ax1, ax2, ax3, ax5, ax6]:\n            ax.clear()\n        \n        view_projection(ax1, field_components=jnp.array([1.0, 0.0, 0.0]),\n                      orient=orient, adiabatic_radius=adiabatic_radius,\n                      title=\"Pure Dipole\")\n        view_projection(ax2, field_components=jnp.array([0.0, 1.0, 0.0]),\n                      orient=orient, adiabatic_radius=adiabatic_radius,\n                      title=\"Pure Quadrupole\")\n        view_projection(ax3, field_components=jnp.array([0.0, 0.0, 1.0]),\n                      orient=orient, adiabatic_radius=adiabatic_radius,\n                      title=\"Pure Octupole\")\n        view_projection(ax5, \n                        field_components=jnp.array([1.0, quad_scale * 1.0, 0.0]),\n                        orient=orient, adiabatic_radius=adiabatic_radius,\n                        title=\"Dipole + Quadrupole\")\n        view_projection(ax6,\n                        field_components=jnp.array([1.0, 0.0, octu_scale * 1.0]),\n                        orient=orient, adiabatic_radius=adiabatic_radius,\n                        title=\"Dipole + Octupole\")\n        \n        plt.suptitle(f\"Phi = {phi:.2f} radians\", fontsize=14)\n        plt.tight_layout()\n    \n    # Create the animation\n    anim = FuncAnimation(fig, update, frames=n_frames, interval=100)\n    plt.close(fig)\n    plt.ion()\n    \n    return anim\n\n# Save the animation using:\n# anim.save('field_rotation_matplotlib.gif', writer='pillow', dpi=100)\n\ndef display_animation(anim):\n    from matplotlib import rc\n    from IPython.display import HTML\n\n    # Temporarily enable JavaScript for the HTML video display\n    rc('animation', html='jshtml')\n\n    # Convert animation to HTML and display it\n    return HTML(anim.to_jshtml())\n\n\n\n\nCode\nanim = create_animation(theta=jnp.pi/4.0,\n                        adiabatic_radius=5.0,\n                        octu_scale=8.0)\n\ndisplay_animation(anim)\n\n\n\n\n\n\n\n\n\n  \n  \n    \n    \n      \n          \n      \n        \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n    \n    \n      \n      Once\n      \n      Loop\n      \n      Reflect\n    \n  \n\n\n\n\n\n\n&lt;Figure size 640x480 with 0 Axes&gt;\n\n\nHere, the phase-resolved \\(\\mathcal{Q},\\ \\mathcal{U}\\) are shown to be greatly different from the pure dipole magnetic field view."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Navigation",
    "section": "",
    "text": "This is a Quarto website containing links to my pre-computed Jupyter notebooks.\nMore information about Quarto and its websites publishing capabilities is available at https://quarto.org/docs/websites."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This site contains some of my current research notebooks."
  }
]